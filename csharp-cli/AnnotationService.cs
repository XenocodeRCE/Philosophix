using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

/// <summary>
/// Service d'annotation automatique de copies, inspir√© du script PHP d'origine
/// </summary>
public class AnnotationService
{
    private readonly ILLMService _llmService;
    private readonly JsonDatabaseService _dbService;

    public AnnotationService(ILLMService llmService, JsonDatabaseService dbService)
    {
        _llmService = llmService;
        _dbService = dbService;
    }/// <summary>
    /// G√©n√®re des annotations pour une copie d√©j√† corrig√©e
    /// </summary>
    public async Task<AnnotationResponse> GenererAnnotationsAsync(Correction correction)
    {
        if (correction == null || string.IsNullOrEmpty(correction.Copie))
        {
            throw new ArgumentException("La correction et la copie ne peuvent pas √™tre vides");
        }

        // Pr√©parer les points forts et points √† am√©liorer sous forme de cha√Ænes
        var pointsForts = correction.PointsForts?.Any() == true 
            ? string.Join(", ", correction.PointsForts) 
            : "Aucun point fort sp√©cifique identifi√©";

        var pointsAmeliorer = correction.PointsAmeliorer?.Any() == true 
            ? string.Join(", ", correction.PointsAmeliorer) 
            : "Aucun point d'am√©lioration sp√©cifique identifi√©";        // Construire un prompt plus direct et efficace
        var prompt = $@"Analysez cette copie de philosophie et identifiez exactement 5 passages √† commenter de mani√®re constructive.

COPIE D'√âL√àVE :
{correction.Copie}

INFORMATIONS DE CORRECTION :
- Note : {correction.Note:F1}/20
- Points forts : {pointsForts}
- Points √† am√©liorer : {pointsAmeliorer}

INSTRUCTIONS :
1. S√©lectionnez 5 passages diff√©rents de la copie (citations exactes)
2. Pour chaque passage, donnez un commentaire constructif
3. Variez les types : structure, argumentation, concepts, style, etc.

R√âPONDEZ UNIQUEMENT au format JSON suivant (sans texte avant ou apr√®s) :
{{
    ""annotations"": [
        {{
            ""passage"": ""premi√®re citation exacte du texte"",
            ""commentaire"": ""commentaire constructif""
        }},
        {{
            ""passage"": ""deuxi√®me citation exacte du texte"",
            ""commentaire"": ""autre commentaire constructif""
        }},
        {{
            ""passage"": ""troisi√®me citation exacte du texte"",
            ""commentaire"": ""encore un commentaire""
        }},
        {{
            ""passage"": ""quatri√®me citation exacte du texte"",
            ""commentaire"": ""commentaire p√©dagogique""
        }},
        {{
            ""passage"": ""cinqui√®me citation exacte du texte"",
            ""commentaire"": ""dernier commentaire""
        }}
    ]
}}";var systemMessage = @"Vous √™tes un professeur de philosophie exp√©riment√©. Votre t√¢che est d'annoter des copies d'√©l√®ves en identifiant des passages sp√©cifiques et en fournissant des commentaires constructifs. R√©pondez UNIQUEMENT avec du JSON valide, sans texte suppl√©mentaire.";

        string response = "";
        string cleanResponse = "";
        
        try
        {
            Console.WriteLine("\nüîç G√©n√©ration des annotations...");
            
            response = await _llmService.AskAsync(systemMessage, prompt, "Annotation");
            
            if (string.IsNullOrEmpty(response))
            {
                throw new Exception("R√©ponse vide de l'API OpenAI");
            }            Console.WriteLine($"üìÑ R√©ponse brute re√ßue (d√©but) : {response.Substring(0, Math.Min(response.Length, 200))}...");

            // Extraire le contenu du message depuis la r√©ponse OpenAI
            cleanResponse = ExtraireContenuMessage(response);
            
            Console.WriteLine($"üîß Contenu extrait : {cleanResponse.Substring(0, Math.Min(cleanResponse.Length, 200))}...");

            // Tenter de d√©s√©rialiser la r√©ponse JSON
            var annotationResponse = JsonSerializer.Deserialize<AnnotationResponse>(cleanResponse, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true
            });            if (annotationResponse == null)
            {
                throw new Exception("Impossible de d√©s√©rialiser la r√©ponse JSON");
            }

            // S'assurer que le texte est pr√©sent
            if (string.IsNullOrEmpty(annotationResponse.Texte))
            {
                annotationResponse.Texte = correction.Copie ?? "";
            }

            if (annotationResponse.Annotations == null || !annotationResponse.Annotations.Any())
            {
                Console.WriteLine("‚ö†Ô∏è  Aucune annotation dans la r√©ponse, tentative avec un prompt simplifi√©...");
                return await GenererAnnotationsSimplifiees(correction);
            }

            // Sauvegarder les annotations dans la correction
            await SauvegarderAnnotationsAsync(correction.Id, cleanResponse);

            Console.WriteLine($"‚úÖ {annotationResponse.Annotations.Count} annotations g√©n√©r√©es avec succ√®s");
            
            return annotationResponse;
        }        catch (JsonException ex)
        {
            Console.WriteLine($"‚ùå Erreur JSON : {ex.Message}");
            Console.WriteLine($"R√©ponse probl√©matique : {cleanResponse}");
            
            // Tentative de r√©cup√©ration avec un prompt simplifi√©
            return await GenererAnnotationsSimplifiees(correction);
        }
        catch (Exception ex)
        {
            throw new Exception($"Erreur lors de la g√©n√©ration des annotations : {ex.Message}");
        }
    }

    /// <summary>
    /// G√©n√®re des annotations avec un prompt simplifi√© en cas d'√©chec
    /// </summary>
    private async Task<AnnotationResponse> GenererAnnotationsSimplifiees(Correction correction)
    {
        try
        {
            Console.WriteLine("üîÑ Tentative avec un prompt simplifi√©...");            var promptSimple = $@"Trouvez 3 passages dans cette copie de philosophie et commentez-les :

{correction.Copie}

Format de r√©ponse JSON requis (UNIQUEMENT ce JSON) :
{{
    ""annotations"": [
        {{""passage"": ""premi√®re citation exacte"", ""commentaire"": ""premier commentaire""}},
        {{""passage"": ""deuxi√®me citation exacte"", ""commentaire"": ""deuxi√®me commentaire""}},
        {{""passage"": ""troisi√®me citation exacte"", ""commentaire"": ""troisi√®me commentaire""}}
    ]
}}";            var response = await _llmService.AskAsync(
                "Vous √™tes professeur de philosophie. R√©pondez en JSON uniquement.", 
                promptSimple, 
                "Annotation simplifi√©e"
            );

            // Extraire le contenu du message depuis la r√©ponse OpenAI
            var cleanResponse = ExtraireContenuMessage(response ?? "");

            var result = JsonSerializer.Deserialize<AnnotationResponse>(cleanResponse, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true
            });

            result ??= new AnnotationResponse { Annotations = new List<AnnotationItem>() };
            result.Texte = correction.Copie ?? "";

            if (result.Annotations?.Any() == true)
            {
                await SauvegarderAnnotationsAsync(correction.Id, cleanResponse);
                Console.WriteLine($"‚úÖ {result.Annotations.Count} annotations g√©n√©r√©es (mode simplifi√©)");
            }
            else
            {
                Console.WriteLine("‚ö†Ô∏è  Aucune annotation g√©n√©r√©e m√™me en mode simplifi√©");
            }

            return result;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå √âchec du mode simplifi√© : {ex.Message}");
            return new AnnotationResponse 
            { 
                Texte = correction.Copie ?? "",
                Annotations = new List<AnnotationItem>()
            };
        }
    }

    /// <summary>
    /// Sauvegarde les annotations dans la base de donn√©es
    /// </summary>
    private async Task SauvegarderAnnotationsAsync(int correctionId, string annotationsJson)
    {
        try
        {
            // Lire les corrections existantes
            var corrections = await _dbService.LireCorrectionsAsync();
            var correctionIndex = corrections.FindIndex(c => c.Id == correctionId);
            
            if (correctionIndex == -1)
            {
                throw new Exception($"Correction avec l'ID {correctionId} introuvable");
            }

            // Ajouter les annotations √† la correction (on pourrait ajouter une propri√©t√© Annotations √† la classe Correction)
            // Pour l'instant, on stocke dans un fichier s√©par√©
            var nomFichierAnnotations = $"annotations_{correctionId}.json";
            await System.IO.File.WriteAllTextAsync(nomFichierAnnotations, annotationsJson);
            
            Console.WriteLine($"üíæ Annotations sauvegard√©es dans {nomFichierAnnotations}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ö†Ô∏è  Erreur lors de la sauvegarde des annotations : {ex.Message}");
        }
    }    /// <summary>
    /// Affiche les annotations de mani√®re format√©e par type
    /// </summary>
    public static void AfficherAnnotations(AnnotationResponse annotations)
    {
        Console.WriteLine("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Console.WriteLine("‚ïë                     ANNOTATIONS                      ‚ïë");
        Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        if (annotations.Annotations == null || !annotations.Annotations.Any())
        {
            Console.WriteLine("Aucune annotation disponible.");
            return;
        }

        Console.WriteLine($"\nüìù Nombre total d'annotations : {annotations.Annotations.Count}");
        
        // Grouper les annotations pour un affichage plus intelligent
        var groupes = new Dictionary<string, List<AnnotationItem>>();
        
        foreach (var annotation in annotations.Annotations)
        {
            // D√©terminer le type probable bas√© sur le contenu du commentaire
            var type = DeterminerTypeAnnotation(annotation.Commentaire);
            
            if (!groupes.ContainsKey(type))
                groupes[type] = new List<AnnotationItem>();
            
            groupes[type].Add(annotation);
        }

        // Afficher par groupe
        foreach (var groupe in groupes.OrderBy(g => GetOrdreType(g.Key)))
        {
            var emoji = groupe.Key switch
            {
                "Structure" => "üèóÔ∏è",
                "Argumentation" => "üí≠", 
                "Concepts" => "üîç",
                "Points positifs" => "‚ú®",
                _ => "üìù"
            };

            Console.WriteLine($"\n{emoji} {groupe.Key.ToUpper()} ({groupe.Value.Count} annotations)");
            Console.WriteLine(new string('‚îÄ', 60));

            for (int i = 0; i < groupe.Value.Count; i++)
            {
                var annotation = groupe.Value[i];
                Console.WriteLine($"\nÔøΩ {groupe.Key} {i + 1}:");
                Console.WriteLine($"   üìÑ Passage : \"{TronquerTexte(annotation.Passage, 80)}\"");
                Console.WriteLine($"   üí¨ Commentaire : {annotation.Commentaire}");
                
                if (i < groupe.Value.Count - 1)
                    Console.WriteLine(new string('¬∑', 40));
            }
        }
    }

    /// <summary>
    /// D√©termine le type d'annotation bas√© sur le contenu du commentaire
    /// </summary>
    private static string DeterminerTypeAnnotation(string commentaire)
    {
        var commentaireLower = commentaire.ToLower();
        
        if (commentaireLower.Contains("structure") || commentaireLower.Contains("introduction") || 
            commentaireLower.Contains("conclusion") || commentaireLower.Contains("plan") ||
            commentaireLower.Contains("transition") || commentaireLower.Contains("organisation"))
            return "Structure";
            
        if (commentaireLower.Contains("argument") || commentaireLower.Contains("raisonnement") || 
            commentaireLower.Contains("exemple") || commentaireLower.Contains("d√©monstration") ||
            commentaireLower.Contains("th√®se") || commentaireLower.Contains("objection"))
            return "Argumentation";
            
        if (commentaireLower.Contains("concept") || commentaireLower.Contains("notion") || 
            commentaireLower.Contains("d√©finition") || commentaireLower.Contains("terme") ||
            commentaireLower.Contains("vocabulaire") || commentaireLower.Contains("clarifier"))
            return "Concepts";
            
        if (commentaireLower.Contains("bien") || commentaireLower.Contains("bon") || 
            commentaireLower.Contains("pertinent") || commentaireLower.Contains("int√©ressant") ||
            commentaireLower.Contains("r√©ussi") || commentaireLower.Contains("prometteur"))
            return "Points positifs";
            
        return "Autres";
    }

    /// <summary>
    /// Retourne l'ordre d'affichage des types
    /// </summary>
    private static int GetOrdreType(string type)
    {
        return type switch
        {
            "Structure" => 1,
            "Argumentation" => 2,
            "Concepts" => 3,
            "Points positifs" => 4,
            _ => 5
        };
    }

    /// <summary>
    /// Charge les annotations depuis un fichier
    /// </summary>
    public async Task<AnnotationResponse?> ChargerAnnotationsAsync(int correctionId)
    {
        try
        {
            var nomFichierAnnotations = $"annotations_{correctionId}.json";
            
            if (!System.IO.File.Exists(nomFichierAnnotations))
            {
                return null;
            }

            var contenu = await System.IO.File.ReadAllTextAsync(nomFichierAnnotations);
            
            return JsonSerializer.Deserialize<AnnotationResponse>(contenu, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ö†Ô∏è  Erreur lors du chargement des annotations : {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Exporte les annotations vers un fichier texte lisible
    /// </summary>
    public static async Task ExporterAnnotationsAsync(AnnotationResponse annotations, Correction correction, Devoir devoir)
    {
        try
        {
            var nomFichier = $"annotations_correction_{correction.Id}_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
            var contenu = new StringBuilder();

            contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            contenu.AppendLine("                        ANNOTATIONS                        ");
            contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            contenu.AppendLine();
            contenu.AppendLine($"üìö Devoir : {devoir.Titre}");
            contenu.AppendLine($"üìù Type : {devoir.Type}");
            contenu.AppendLine($"üìÖ Date d'annotation : {DateTime.Now:dd/MM/yyyy √† HH:mm}");
            contenu.AppendLine($"üéØ Note obtenue : {correction.Note:F1}/20");
            contenu.AppendLine();
            contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            contenu.AppendLine("                      COPIE DE L'√âL√àVE");
            contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            contenu.AppendLine();
            contenu.AppendLine(correction.Copie);
            contenu.AppendLine();
            contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            contenu.AppendLine("                       ANNOTATIONS");
            contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");

            if (annotations.Annotations?.Any() == true)
            {
                for (int i = 0; i < annotations.Annotations.Count; i++)
                {
                    var annotation = annotations.Annotations[i];
                    contenu.AppendLine();
                    contenu.AppendLine($"üîç ANNOTATION {i + 1}");
                    contenu.AppendLine($"   üìÑ Passage surlign√© :");
                    contenu.AppendLine($"      \"{annotation.Passage}\"");
                    contenu.AppendLine();
                    contenu.AppendLine($"   üí¨ Commentaire :");
                    contenu.AppendLine($"      {annotation.Commentaire}");
                    contenu.AppendLine(new string('¬∑', 50));
                }
            }
            else
            {
                contenu.AppendLine("\nAucune annotation disponible.");
            }

            contenu.AppendLine();
            contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            contenu.AppendLine($"Fichier g√©n√©r√© par Philosophix CLI v2.0 - {DateTime.Now:dd/MM/yyyy HH:mm}");
            contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

            await System.IO.File.WriteAllTextAsync(nomFichier, contenu.ToString());
            Console.WriteLine($"üìÑ Annotations export√©es vers : {nomFichier}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Erreur lors de l'export : {ex.Message}");
        }
    }

    /// <summary>
    /// Extrait le contenu du message depuis la r√©ponse OpenAI compl√®te
    /// </summary>
    private string ExtraireContenuMessage(string responseOpenAI)
    {
        try
        {
            // Parse la r√©ponse OpenAI pour extraire le contenu du message
            using var document = JsonDocument.Parse(responseOpenAI);
            var root = document.RootElement;

            if (root.TryGetProperty("choices", out var choices) && choices.GetArrayLength() > 0)
            {
                var firstChoice = choices[0];
                if (firstChoice.TryGetProperty("message", out var message))
                {
                    if (message.TryGetProperty("content", out var content))
                    {
                        var contentText = content.GetString() ?? "";
                        
                        // Nettoyer le contenu (enlever les √©ventuels backticks markdown)
                        contentText = contentText.Trim();
                        if (contentText.StartsWith("```json"))
                        {
                            contentText = contentText.Substring(7);
                        }
                        if (contentText.StartsWith("```"))
                        {
                            contentText = contentText.Substring(3);
                        }
                        if (contentText.EndsWith("```"))
                        {
                            contentText = contentText.Substring(0, contentText.Length - 3);
                        }
                        
                        return contentText.Trim();
                    }
                }
            }

            // Si on ne trouve pas la structure attendue, retourner la r√©ponse brute
            Console.WriteLine("‚ö†Ô∏è  Structure OpenAI non reconnue, utilisation de la r√©ponse brute");
            return responseOpenAI;
        }
        catch (JsonException ex)
        {
            Console.WriteLine($"‚ö†Ô∏è  Erreur lors de l'extraction du contenu : {ex.Message}");
            return responseOpenAI;
        }
    }

    /// <summary>
    /// Utilitaire pour tronquer le texte
    /// </summary>
    private static string TronquerTexte(string texte, int longueurMax)
    {
        if (string.IsNullOrEmpty(texte) || texte.Length <= longueurMax)
            return texte;

        return texte.Substring(0, longueurMax) + "...";
    }

    /// <summary>
    /// G√©n√®re des annotations pour un type sp√©cifique (comme dans le script PHP)
    /// </summary>
    private async Task<List<AnnotationItem>> GenererAnnotationsParType(Correction correction, string type)
    {
        // Pr√©parer les points forts et points √† am√©liorer
        var pointsForts = correction.PointsForts?.Any() == true 
            ? string.Join(", ", correction.PointsForts) 
            : "Aucun point fort sp√©cifique identifi√©";

        var pointsAmeliorer = correction.PointsAmeliorer?.Any() == true 
            ? string.Join(", ", correction.PointsAmeliorer) 
            : "Aucun point d'am√©lioration sp√©cifique identifi√©";

        // D√©finir le prompt selon le type (exactement comme dans le PHP)
        var promptType = type switch
        {
            "structure" => @"En tant que professeur de philosophie exp√©riment√©, analysez en d√©tail la structure du texte. Identifiez au moins 8-10 √©l√©ments parmi :
            - Introduction : accroche, probl√©matisation, annonce du plan
            - Transitions entre les parties et paragraphes
            - Structure interne des paragraphes
            - Organisation logique des arguments
            - Conclusion : synth√®se et ouverture
            - Articulation des id√©es
            - Coh√©rence du d√©veloppement
            - √âquilibre des parties",

            "argument" => @"En tant que professeur de philosophie exp√©riment√©, analysez en d√©tail l'argumentation. Identifiez au moins 8-10 √©l√©ments parmi :
            - Arguments principaux √† renforcer
            - Raisonnements √† compl√©ter
            - Exemples √† d√©velopper
            - Th√®ses √† approfondir
            - Objections √† anticiper
            - R√©f√©rences philosophiques √† exploiter davantage (pas de nouvelles)
            - D√©monstrations √† enrichir
            - Analyses √† poursuivre
            - Implications √† explorer",

            "concept" => @"En tant que professeur de philosophie exp√©riment√©, analysez en d√©tail les concepts utilis√©s. Identifiez au moins 8-10 √©l√©ments parmi :
            - Concepts philosophiques √† d√©finir
            - Notions cl√©s √† clarifier
            - Distinctions conceptuelles √† √©tablir
            - Pr√©suppos√©s √† expliciter
            - Termes ambigus √† pr√©ciser
            - Champs lexicaux √† enrichir
            - Relations entre concepts √† d√©velopper
            - Implications th√©oriques √† approfondir
            - Usage des concepts dans le raisonnement",

            "good" => @"En tant que professeur de philosophie exp√©riment√©, identifiez au moins 8-10 points prometteurs parmi :
            - Intuitions philosophiques pertinentes
            - Arguments bien construits
            - Exemples bien choisis
            - R√©f√©rences philosophiques appropri√©es √† exploiter davantage (pas de nouvelles)
            - Analyses nuanc√©es
            - R√©flexions originales
            - Raisonnements rigoureux
            - Probl√©matisations int√©ressantes
            - Transitions r√©ussies
            - D√©veloppements prometteurs",

            _ => "Analysez cette copie et identifiez des passages importants."
        };

        var prompt = $@"{promptType}

Voici une copie d'√©l√®ve :
{correction.Copie}

Note: {correction.Note:F1}/20
Appr√©ciation: {correction.Appreciation}

IMPORTANT : 
1. Chaque passage identifi√© doit √™tre une citation EXACTE du texte.
2. Les commentaires doivent √™tre constructifs et donner des pistes d'am√©lioration concr√®tes.
3. Adaptez le niveau des commentaires √† un √©l√®ve de terminale de 16 ans.
4. Je veux minimum 8 annotations si c'est possible (mais plus c'est mieux).
5. Tu ne dois pas conseiller une r√©f√©rence philosophique nouvelle, mais tu peux sugg√©rer d'approfondir une r√©f√©rence d√©j√† utilis√©e.

R√©pondez UNIQUEMENT au format JSON suivant :
{{
    ""annotations"": [
        {{
            ""passage"": ""<citation exacte du texte>"",
            ""commentaire"": ""<commentaire constructif et piste d'am√©lioration>""
        }}
    ]
}}";

        var systemMessage = $"Vous √™tes un professeur de philosophie qui annote des copies selon le type '{type}'. R√©pondez UNIQUEMENT avec du JSON valide.";        try
        {
            var response = await _llmService.AskAsync(systemMessage, prompt, $"Annotation {type}");
            
            if (string.IsNullOrEmpty(response))
            {
                return new List<AnnotationItem>();
            }

            var cleanResponse = ExtraireContenuMessage(response);
            
            var annotationResponse = JsonSerializer.Deserialize<AnnotationResponse>(cleanResponse, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true
            });

            return annotationResponse?.Annotations ?? new List<AnnotationItem>();
        }
        catch (Exception)
        {
            // Erreurs g√©r√©es au niveau sup√©rieur pour la barre de progression
            return new List<AnnotationItem>();
        }
    }    /// <summary>
    /// NOUVELLE VERSION : G√©n√®re des annotations pour une copie d√©j√† corrig√©e (avec 4 types comme PHP)
    /// </summary>
    public async Task<AnnotationResponse> GenererAnnotationsAvecTypes(Correction correction)
    {
        if (correction == null || string.IsNullOrEmpty(correction.Copie))
        {
            throw new ArgumentException("La correction et la copie ne peuvent pas √™tre vides");
        }

        Console.WriteLine("\nüîç G√©n√©ration des annotations par type (en parall√®le)...");

        var types = new[] { "structure", "argument", "concept", "good" };
        
        // Afficher la barre de progression
        AfficherBarreProgression(0, types.Length, "Initialisation...");

        // G√©n√©rer les 4 types d'annotations en parall√®le
        var taches = types.Select(async (type, index) =>
        {
            try
            {
                var annotationsType = await GenererAnnotationsParType(correction, type);
                
                // Mettre √† jour la barre de progression
                AfficherBarreProgression(index + 1, types.Length, $"Termin√©: {type} ({annotationsType.Count} annotations)");
                
                return new { Type = type, Annotations = annotationsType };
            }
            catch (Exception ex)
            {
                AfficherBarreProgression(index + 1, types.Length, $"Erreur: {type}");
                Console.WriteLine($"\n‚ö†Ô∏è  Erreur pour le type {type} : {ex.Message}");
                return new { Type = type, Annotations = new List<AnnotationItem>() };
            }
        }).ToArray();

        var resultats = await Task.WhenAll(taches);

        // Combiner toutes les annotations
        var tousesAnnotations = new List<AnnotationItem>();
        foreach (var resultat in resultats)
        {
            tousesAnnotations.AddRange(resultat.Annotations);
        }

        // Effacer la ligne de progression et afficher le r√©sum√©
        Console.Write("\r" + new string(' ', Console.WindowWidth - 1) + "\r");
        
        var response = new AnnotationResponse
        {
            Texte = correction.Copie ?? "",
            Annotations = tousesAnnotations
        };

        if (tousesAnnotations.Any())
        {
            // Sauvegarder toutes les annotations
            await SauvegarderAnnotationsAsync(correction.Id, JsonSerializer.Serialize(response, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true
            }));

            // Afficher le r√©sum√© par type
            Console.WriteLine("üéØ R√âSUM√â DES ANNOTATIONS G√âN√âR√âES :");
            foreach (var resultat in resultats)
            {
                var emoji = resultat.Type switch
                {
                    "structure" => "üèóÔ∏è",
                    "argument" => "üí≠",
                    "concept" => "üîç",
                    "good" => "‚ú®",
                    _ => "üìù"
                };
                Console.WriteLine($"   {emoji} {resultat.Type.PadRight(12)} : {resultat.Annotations.Count,2} annotations");
            }
            Console.WriteLine($"   üéØ TOTAL           : {tousesAnnotations.Count,2} annotations");
        }
        else
        {
            Console.WriteLine("‚ö†Ô∏è  Aucune annotation g√©n√©r√©e, tentative avec mode simplifi√©...");
            return await GenererAnnotationsSimplifiees(correction);
        }

        return response;
    }

    /// <summary>
    /// Affiche une barre de progression √©l√©gante dans la console
    /// </summary>
    private static void AfficherBarreProgression(int actuel, int total, string message = "")
    {
        var largeur = Math.Min(50, Console.WindowWidth - 30);
        var pourcentage = (double)actuel / total;
        var barreRemplie = (int)(pourcentage * largeur);
        
        var barre = new StringBuilder();
        barre.Append('[');
        
        for (int i = 0; i < largeur; i++)
        {
            if (i < barreRemplie)
                barre.Append('‚ñà');
            else
                barre.Append('‚ñë');
        }
        
        barre.Append(']');
        
        var pourcentageStr = $"{pourcentage * 100:F0}%".PadLeft(4);
        var compteur = $"{actuel}/{total}".PadLeft(7);
        
        // Tronquer le message si n√©cessaire
        var maxMessageLength = Console.WindowWidth - barre.Length - pourcentageStr.Length - compteur.Length - 10;
        if (message.Length > maxMessageLength && maxMessageLength > 0)
        {
            message = message.Substring(0, maxMessageLength - 3) + "...";
        }
        
        Console.Write($"\r{barre} {pourcentageStr} {compteur} {message}");
    }

    // ...existing code...
}

/// <summary>
/// Classe pour la r√©ponse d'annotation de l'API
/// </summary>
public class AnnotationResponse
{
    [JsonPropertyName("texte")]
    public string Texte { get; set; } = string.Empty;

    [JsonPropertyName("annotations")]
    public List<AnnotationItem> Annotations { get; set; } = new();
}

/// <summary>
/// Classe pour un √©l√©ment d'annotation individuel
/// </summary>
public class AnnotationItem
{
    [JsonPropertyName("passage")]
    public string Passage { get; set; } = string.Empty;

    [JsonPropertyName("commentaire")]
    public string Commentaire { get; set; } = string.Empty;
}
