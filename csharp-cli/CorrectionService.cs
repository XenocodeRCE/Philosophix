using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Text;
using System.Text.Json;
using System.Threading;

public class CorrectionService
{
    private readonly ILLMService _llmService;
    private readonly JsonDatabaseService _dbService;

    public CorrectionService(ILLMService llmService, JsonDatabaseService dbService)
    {
        _llmService = llmService;
        _dbService = dbService;
    }

    /// <summary>
    /// Obtient le niveau de s√©v√©rit√© selon le type de bac
    /// </summary>
    private string GetSeverite(string typeBac)
    {
        return typeBac switch
        {
            "technologique" => @"INSTRUCTIONS DE NOTATION pour BAC TECHNOLOGIQUE :
- Cette copie doit √™tre √©valu√©e selon les standards r√©els du bac technologique
- Ne donnez PAS la m√™me note √† toutes les comp√©tences
- Soyez diff√©renci√© : certaines comp√©tences peuvent avoir 8-9/20, d'autres 11-13/20
- N'h√©sitez pas √† donner des notes en dessous de 10/20 si la comp√©tence est insuffisante
- Basez-vous sur l'√©chelle : 6-9 = insuffisant, 10-11 = correct, 12-14 = bien, 15+ = tr√®s bien",

            "g√©n√©ral" => "Degr√© de s√©v√©rit√© : 3 / 5",
            _ => "Degr√© de s√©v√©rit√© : 3 / 5"
        };    }

    // Suppression de l'ancien constructeur OpenAI-sp√©cifique
    // Il est maintenant remplac√© par le constructeur ILLMService/// <summary>
         /// Lance le processus complet de correction d'une copie
         /// </summary>
    public async Task<Correction> CorrigerCopieAsync(Devoir devoir, string copie, bool aPAP = false)
    {
        Console.WriteLine("\n" + new string('‚ïê', 60));
        Console.WriteLine("ü§ñ CORRECTION EN COURS...");
        Console.WriteLine(new string('‚ïê', 60));

        // Analyse linguistique de la copie
        var (nombreMots, motsUniques, richesseVocabulaire, motsPlusFrequents) = AnalyserMetriquesLinguistiques(copie);
        var mtld = CalculerMTLD(copie);
        var analyseLinguistique = InterpreterMTLD(mtld, nombreMots, devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral");
        
        Console.WriteLine($"üìä ANALYSE LINGUISTIQUE :");
        Console.WriteLine($"   ‚Ä¢ Longueur : {nombreMots} mots ({motsUniques} uniques, {richesseVocabulaire:F1}% de richesse)");
        var qualiteMTLD = mtld >= 50 ? "excellent" : mtld >= 40 ? "tr√®s bon" : mtld >= 30 ? "correct" : mtld >= 20 ? "faible" : "tr√®s faible";
        Console.WriteLine($"   ‚Ä¢ Diversit√© lexicale (MTLD) : {mtld:F1} ({qualiteMTLD})");
        Console.WriteLine($"   ‚Ä¢ Mots les plus fr√©quents : {string.Join(", ", motsPlusFrequents.Take(5))}");
        Console.WriteLine();

        var competences = devoir.Bareme?.Competences ?? new List<Competence>();
        // Filtrer les comp√©tences si PAP (exclure la comp√©tence "Ma√Ætrise de la langue fran√ßaise" ou "Expression et r√©daction")
        if (aPAP)
        {
            Console.WriteLine("‚ÑπÔ∏è  PAP activ√© : Les comp√©tences d'expression ne seront pas √©valu√©es.");
            if (devoir.Type?.ToLower() == "explication")
            {
                // retirer la comp√©tence 6, Nom = "Expression et r√©daction"
                competences = competences.Where(c => c.Nom != "Expression et r√©daction").ToList();
            }
            else
            {
                // retirer la comp√©tence 5, Nom = "Ma√Ætrise de la langue fran√ßaise"
                competences = competences.Where(c => c.Nom != "Ma√Ætrise de la langue fran√ßaise").ToList();
            }
        }

        var evaluations = new List<EvaluationCompetence>();

        // √âvaluation par comp√©tence
        for (int i = 0; i < competences.Count; i++)
        {
            var competence = competences[i];
            Console.WriteLine($"\nüìã √âvaluation de la comp√©tence {i + 1}/{competences.Count}:");
            Console.WriteLine($"   {competence.Nom}");
            Console.Write("   Analyse en cours");
            var evaluation = await EvaluerCompetenceAsync(competence, copie, devoir.Enonce ?? "", devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral", aPAP);

            evaluations.Add(evaluation);
            Console.WriteLine($" ‚úÖ Note: {evaluation.Note:F1}/20");
        }

        // √âvaluation finale
        Console.WriteLine("\nüéØ G√©n√©ration de l'√©valuation finale...");
        var evaluationFinale = await EvaluerFinalAsync(evaluations, competences, copie, devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral", aPAP);        // Afficher le r√©sum√© des co√ªts
        Console.WriteLine("\n" + new string('‚îÄ', 60));
        _llmService.CostTracker?.DisplayCostSummary();

        // Calcul de la note moyenne
        var notesAjustees = evaluations.Select(e => AjusterNoteSelonNiveau(Convert.ToDouble(e.Note), devoir.TypeBac ?? "g√©n√©ral")).ToList();


        // Calcul de la note moyenne avec pond√©ration intelligente
        var notesFinales = evaluations.Select(e => e.Note).ToList();
        var notesFinalesDouble = notesFinales.Select(n => Convert.ToDouble(n)).ToList();
        var noteMoyenne = AppliquerPonderation(notesFinalesDouble, devoir.TypeBac ?? "g√©n√©ral", evaluations, devoir.Type ?? "dissertation");

        // Afficher les d√©tails pour le bac technologique
        if (devoir.TypeBac == "technologique")
        {
            var noteSansAjustement = evaluations.Average(e => e.Note);
            Console.WriteLine($"üìä Note moyenne des comp√©tences : {noteSansAjustement:F1}/20");
            Console.WriteLine($"üìä Note finale apr√®s pond√©ration bac techno : {noteMoyenne:F1}/20");

            // Debug : afficher quelques extraits d'analyse pour v√©rification
            Console.WriteLine("üîç Extraits d'analyses pour v√©rification :");
            foreach (var eval in evaluations.Take(2))
            {
                var extrait = eval.Analyse?.Substring(0, Math.Min(eval.Analyse.Length, 100)) ?? "";
                Console.WriteLine($"   ‚Ä¢ {eval.Nom}: {extrait}...");
            }
        }

        // Cr√©ation de la correction
        var corrections = await _dbService.LireCorrectionsAsync();
        var newId = corrections.Count > 0 ? corrections.Max(c => c.Id) + 1 : 1;

        var correction = new Correction
        {
            Id = newId,
            DevoirId = devoir.Id,
            Note = (decimal)noteMoyenne,
            Appreciation = evaluationFinale.Appreciation + $"\n\n[Analyse linguistique MTLD: {analyseLinguistique}]",
            PointsForts = evaluationFinale.PointsForts,
            PointsAmeliorer = evaluationFinale.PointsAmeliorer,
            Competences = evaluations,
            Copie = copie,
            DateCorrection = DateTime.Now
        };

        corrections.Add(correction);
        await _dbService.SauvegarderCorrectionsAsync(corrections);

        return correction;
    }    /// <summary>
         /// √âvalue une comp√©tence sp√©cifique
         /// </summary>
    private async Task<EvaluationCompetence> EvaluerCompetenceAsync(Competence competence, string copie, string enonce, string typeDevoir, string TypeBac, bool aPAP = false)
    {        var system = $@"Vous √™tes un correcteur de philosophie qui √©value selon les standards R√âELS du bac {TypeBac}.
        
        ATTENTION : Cette copie doit √™tre not√©e de mani√®re DIFF√âRENCI√âE et R√âALISTE.
- Ne donnez PAS la m√™me note √† toutes les comp√©tences
- Utilisez toute l'√©chelle de notation : 6-20/20

IMPORTANT : Vous DEVEZ r√©pondre uniquement avec un objet JSON valide, sans texte suppl√©mentaire avant ou apr√®s.";

        var messagePAP = aPAP ? "\n\nIMPORTANT : Cet √©l√®ve dispose d'un PAP (Plan d'Accompagnement Personnalis√©). Ne tenez pas compte de la qualit√© de l'orthographe, de la grammaire ou de l'expression √©crite dans votre √©valuation. Concentrez-vous uniquement sur le contenu philosophique et la r√©flexion." : "";

        // Adapter le message selon le type de bac
        string messageNiveau = "";
        if (TypeBac == "technologique")
        {
            messageNiveau = "\nüìä NIVEAU : Bac technologique - Adaptez vos attentes au niveau et soyez bienveillant sur les imperfections mineures de forme. Privil√©giez la compr√©hension et les id√©es.";
        }

        var prompt = $@"√âvaluez la comp√©tence ""{competence.Nom}"" .

**COMP√âTENCE √Ä √âVALUER :** 
{competence.Nom}

**CRIT√àRES D'√âVALUATION :**
{string.Join("\n", competence.Criteres ?? new List<string>())}

**√âNONC√â DU DEVOIR :** 
{enonce}

**STYLE D'APPR√âCIATION :**
Formel, vouvoie l'apprenant.

**TYPE DE DEVOIR:**
{typeDevoir}{messagePAP}

**COPIE DE L'√âL√àVE :**
{copie}
{messagePAP}{messageNiveau}

R√©pondez UNIQUEMENT au format JSON suivant (pas de texte avant ou apr√®s) :
{{
    ""note"": <nombre entre 6 et 20>,
    ""analyse"": ""<analyse d√©taill√©e qui cite des √©l√©ments de la copie>"",
    ""points_forts"": [""point fort 1"", ""point fort 2"", ...],
    ""points_ameliorer"": [""point √† am√©liorer 1"", ""point √† am√©liorer 2"", ...]
}}

√âvaluez UNIQUEMENT cette comp√©tence, rien d'autre.
Pour l'analyse, citez des √©l√©ments de la copie pour justifier votre note, et adressez-vous √† l'√©l√®ve directement.

{GetSeverite(TypeBac)}";var response = await _llmService.AskAsync(system, prompt, $"Comp√©tence: {competence.Nom}");
        var evaluation = ParseEvaluationResponse(response);

        // Ajouter le nom de la comp√©tence √† l'√©valuation
        evaluation.Nom = competence.Nom;

        return evaluation;
    }    /// <summary>
         /// G√©n√®re l'√©valuation finale globale
         /// </summary>
    private async Task<EvaluationFinaleApiResponse> EvaluerFinalAsync(List<EvaluationCompetence> evaluations, List<Competence> competences, string copie, string typeDevoir, string TypeBac, bool aPAP = false)
    {
        var system = "Vous √™tes un professeur de philosophie exp√©riment√© qui corrige des r√©dactions. Vous DEVEZ r√©pondre uniquement avec un objet JSON valide, sans texte suppl√©mentaire avant ou apr√®s.";

        var echelleNotation = GetEchelleNotation(typeDevoir);
        var messagePAP = aPAP ? "\n\nIMPORTANT : Cet √©l√®ve dispose d'un PAP (Plan d'Accompagnement Personnalis√©). Dans votre appr√©ciation g√©n√©rale, ne tenez pas compte de la qualit√© de l'orthographe, de la grammaire ou de l'expression √©crite. Concentrez-vous uniquement sur le contenu philosophique et la r√©flexion." : "";

        string messageNiveau = "";
        if (TypeBac == "technologique")
        {
            messageNiveau = "\nüìä NIVEAU : Bac technologique - Adaptez vos attentes au niveau et soyez bienveillant sur les imperfections mineures de forme. Privil√©giez la compr√©hension et les id√©es.";
        }


        var evaluationsText = string.Join("\n", evaluations.Zip(competences, (eval, comp) =>
            $"{comp.Nom}: {eval.Note}/20 - {eval.Analyse}"));

        var prompt = $@"Type de devoir : {typeDevoir}
En tant que professeur de philosophie, faites une √©valuation globale de cette copie.

Voici les √©valuations par comp√©tence :
{evaluationsText}

Copie de l'√©l√®ve :
{copie}

Style d'appr√©ciation : 
Formelle, vouvoie l'apprenant.

{messagePAP}

{messageNiveau}

{echelleNotation}

R√©pondez UNIQUEMENT au format JSON suivant (pas de texte avant ou apr√®s) :
{{
    ""appreciation"": ""<appr√©ciation g√©n√©rale d√©taill√©e>"",
    ""points_forts"": [""point fort 1"", ""point fort 2"", ""point fort 3""],
    ""points_ameliorer"": [""point 1"", ""point 2"", ""point 3""]
}}

Pour l'appr√©ciation, adressez-vous √† l'√©l√®ve directement.
{GetSeverite(TypeBac)}";var response = await _llmService.AskAsync(system, prompt, "√âvaluation finale");
        return ParseEvaluationFinaleResponse(response);
    }

    /// <summary>
    /// Retourne l'√©chelle de notation selon le type de devoir
    /// </summary>
    private static string GetEchelleNotation(string typeDevoir)
    {
        if (typeDevoir?.ToLower() == "dissertation")
        {
            return @"√âchelle d'√©valuation pour guider la notation des copies :
""""""
- Ce qui est valoris√© : une probl√©matisation du sujet, une argumentation coh√©rente et progressive, l'analyse de concepts (notions, distinctions) et d'exemples pr√©cis√©ment √©tudi√©s, la mobilisation d'√©l√©ments de culture philosophique au service du traitement du sujet, la capacit√© de la r√©flexion √† entrer en dialogue avec elle-m√™me. 
- Ce qui est sanctionn√© : la paraphrase du texte, la r√©citation de cours sans lien avec le sujet, l'accumulation de lieux communs, la juxtaposition d'exemples sans r√©flexion, l'absence de probl√©matisation, l'absence de rigueur dans le raisonnement, l'absence de culture philosophique mobilis√©e pour traiter le sujet.

# √âchelle de notation :
- Entre 0 et 5 ‚Üí copie tr√®s insuffisante : inintelligible ; non structur√©e ; excessivement br√®ve ; marquant un refus manifeste de faire l'exercice.
- De 06 √† 09 ‚Üí Copie intelligible mais qui ne r√©pond pas aux crit√®res attest√©s de l'√©preuve : propos excessivement g√©n√©ral ou restant sans rapport avec la question pos√©e ; juxtaposition d'exemples sommaires ou anecdotiques ; accumulation de lieux communs ; paraphrase ou r√©p√©tition du texte ; r√©citation de cours sans traitement du sujet ;- copie qui aurait pu √™tre r√©dig√©e au d√©but de l'ann√©e, sans aucun cours de philosophie ou connaissances acquises.
- Pas moins de 10 ‚Üí Copie t√©moignant d'un r√©el effort de r√©flexion, et, m√™me si le r√©sultat n'est pas abouti, de traitement du sujet : effort de probl√©matisation ; effort de d√©finition des notions ; examen de r√©ponses possibles ; coh√©rence globale du propos.
- Pas moins de 12 ‚Üí Si, en plus, il y a mobilisation de r√©f√©rences et d'exemples pertinents pour le sujet.
- Pas moins de 14 ‚Üí Si, en plus, le raisonnement est construit, progressif, et que les affirmations pos√©es sont rigoureusement justifi√©es.
- Pas moins de 16 ‚Üí Si, en plus, la copie t√©moigne de la ma√Ætrise de concepts philosophiques utiles pour le sujet (notions, rep√®res), d'une d√©marche de recherche et du souci des enjeux de la question, d'une pr√©cision dans l'utilisation d'une culture au service du traitement du sujet. 
""""""";
        }
        else
        {
            return @"√âchelle d'√©valuation pour guider la notation des copies :
""""""
- Ce qui est valoris√© : une d√©termination du probl√®me du texte, une explication de ses √©l√©ments signifiants, une explicitation des articulations du texte, une caract√©risation  de la position philosophique √©labor√©e par  l'auteur dans le texte, et, plus g√©n√©ralement,  du questionnement auquel elle s'articule.
- Ce qui est sanctionn√© : la paraphrase du texte, la r√©citation de cours sans lien avec le texte de l'auteur, l'accumulation de lieux communs, la juxtaposition d'exemples sans r√©flexion, l'absence de probl√©matisation du texte, l'absence de rigueur dans le raisonnement, l'absence de culture philosophique mobilis√©e pour traiter le sujet.

# √âchelle de notation :
- Entre 0 et 5 ‚Üí copie tr√®s insuffisante : inintelligible ; non structur√©e ; excessivement br√®ve ; marquant un refus manifeste de faire l'exercice.
- De 06 √† 09 ‚Üí Copie intelligible mais qui ne r√©pond pas aux crit√®res attest√©s de l'√©preuve : propos excessivement g√©n√©ral ou restant sans rapport avec la question pos√©e ; juxtaposition d'exemples sommaires ou anecdotiques ; accumulation de lieux communs ; paraphrase ou r√©p√©tition du texte ; r√©citation de cours sans traitement du sujet ;- copie qui aurait pu √™tre r√©dig√©e au d√©but de l'ann√©e, sans aucun cours de philosophie ou connaissances acquises.
- Pas moins de 10 ‚Üí Copie faisant l'effort de r√©aliser l'exercice, m√™me si l'explication demeure maladroite et inaboutie : explication commen√ßante ; pas de contresens majeur sur le propos et la d√©marche de l'auteur.
- Pas moins de 12 ‚Üí Si, en plus, le texte est interrog√© avec un effort d'attention au d√©tail du propos, ainsi qu'√† sa structure logique.
- Pas moins de 14 ‚Üí Si, en plus, les √©l√©ments du texte sont mis en perspective, avec des √©l√©ments de connaissance permettant de d√©terminer et d'examiner le probl√®me.
- Pas moins de 16 ‚Üí Si, en plus, l'explication est d√©velopp√©e avec amplitude et justesse : l'ensemble du texte est examin√© et bien situ√© dans une probl√©matique  et un questionnement pertinents.
""""""";
        }
    }


    /// <summary>
    /// Ajuste les notes selon le niveau d'√©valuation pour plus de bienveillance
    /// </summary>
    private double AjusterNoteSelonNiveau(double note, string typeBac)
    {
        return typeBac switch
        {
            "technologique" => Math.Min(20, note + 0.5),
            "g√©n√©ral" => note,
            _ => note
        };
    }


    /// <summary>
    /// D√©tecte la qualit√© globale d'une copie bas√©e sur les √©valuations textuelles
    /// </summary>
    private string DetecterQualiteCopie(List<EvaluationCompetence> evaluations)
    {
        // Mots-cl√©s pour copie de BONNE qualit√©
        var motsClesBons = new[] {
            "pertinente", "pertinent", "solide", "structur√©", "structur√©e", "claire", "clair", "clairement",
            "bon", "bonne", "r√©ussi", "efficace", "appropri√©", "appropri√©e", "coh√©rent", "coh√©rente",
            "int√©ressant", "int√©ressante", "satisfaisant", "satisfaisante", "correct", "correcte",
            "bien", "r√©f√©rences", "philosophiques", "vari√©es", "argumentatif", "argumentative",
            "logique", "fluide", "plan", "probl√©matique", "d√©velopp√©", "d√©velopp√©e", "richesse",
            "qualit√©", "ma√Ætrise", "r√©flexion", "construction", "organisation", "progression",
            "analyse", "synth√®se", "articulation", "engagement", "effort", "capacit√©", "enrichit",
            "enrichissant", "montre", "t√©moigne", "d√©montre", "r√©ussi √†", "parvenez", "identifi√©"
        };

        // Mots-cl√©s pour copie VRAIMENT faible (tr√®s restrictifs)
        var motsClesFaibles = new[] {
            "tr√®s insuffisant", "insuffisant", "extr√™mement faible", "grave lacune",
            "incompr√©hensible", "incoh√©rent totalement", "absent totalement", "inexistant",
            "catastrophique", "d√©sorganis√© compl√®tement", "inintelligible",
            "hors sujet", "sans rapport avec", "refuse de faire", "tr√®s faible"
        };

        // Mots-cl√©s d'am√©lioration (neutres - ne comptent ni pour ni contre)
        var motsClesAmeliorations = new[] {
            "am√©liorer", "clarifier", "pr√©ciser", "d√©velopper", "renforcer", "√©viter",
            "corriger", "veiller", "attention", "pourrait", "aurait pu", "gagnerait",
            "b√©n√©ficier", "manque", "manquer", "perfectible"
        };

        int scoreBon = 0;
        int scoreFaible = 0;
        int scoreAm√©liorations = 0;
        int totalMots = 0;

        foreach (var eval in evaluations)
        {
            var analyseTexte = eval.Analyse?.ToLower() ?? "";
            var pointsForts = string.Join(" ", eval.PointsForts?.Select(p => p.ToLower()) ?? new List<string>());
            var pointsAmeliorer = string.Join(" ", eval.PointsAmeliorer?.Select(p => p.ToLower()) ?? new List<string>());

            var texteComplet = $"{analyseTexte} {pointsForts}";
            var mots = texteComplet.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            totalMots += mots.Length;

            // Compter les occurrences
            foreach (var mot in motsClesBons)
            {
                var matches = System.Text.RegularExpressions.Regex.Matches(texteComplet, $@"\b{mot}\b");
                scoreBon += matches.Count;
            }

            foreach (var mot in motsClesFaibles)
            {
                var matches = System.Text.RegularExpressions.Regex.Matches(texteComplet, $@"\b{mot}\b");
                scoreFaible += matches.Count;
            }

            foreach (var mot in motsClesAmeliorations)
            {
                var matches = System.Text.RegularExpressions.Regex.Matches(texteComplet, $@"\b{mot}\b");
                scoreAm√©liorations += matches.Count;
            }
        }

        // Calcul des densit√©s (pourcentages)
        var densiteBon = totalMots > 0 ? (double)scoreBon / totalMots * 100 : 0;
        var densiteFaible = totalMots > 0 ? (double)scoreFaible / totalMots * 100 : 0;
        var densiteAmeliorations = totalMots > 0 ? (double)scoreAm√©liorations / totalMots * 100 : 0;

        // Calcul des moyennes de notes pour validation crois√©e
        var moyenneNotes = evaluations.Average(e => e.Note);

        Console.WriteLine($"üîç Analyse qualit√© - Positif: {scoreBon}, N√©gatif: {scoreFaible}, Am√©liorations: {scoreAm√©liorations}");
        Console.WriteLine($"üîç Densit√©s - Positif: {densiteBon:F1}%, N√©gatif: {densiteFaible:F1}%, Am√©liorations: {densiteAmeliorations:F1}%");
        Console.WriteLine($"üîç Moyenne des notes: {moyenneNotes:F1}/20");

        // NOUVELLE LOGIQUE CORRIG√âE
        // Une copie est bonne si elle a beaucoup de points positifs ET peu de vrais d√©fauts
        // Une copie est faible si elle a beaucoup de vrais d√©fauts ET peu de points positifs

        // LOGIQUE AJUST√âE : plus restrictive pour les moyennes notes
        if (moyenneNotes >= 14 && densiteBon >= 4.0 && densiteFaible <= 1.0)
        {
            return "bonne";
        }
        else if ((double)moyenneNotes >= 12.5 && densiteBon >= 3.0 && densiteFaible <= 1.5)
        {
            return "bonne";
        }
        else if (moyenneNotes < 9 && densiteFaible >= 2.0 && densiteBon <= 1.5)
        {
            return "faible";
        }
        else
        {
            return "moyenne";
        }
    }

    /// <summary>
    /// Applique une pond√©ration plus subtile selon le type de bac
    /// </summary>
    private double AppliquerPonderation(List<double> notes, string typeBac, List<EvaluationCompetence> evaluations, string typeDevoir = "dissertation")
    {
        var moyenne = notes.Average();
        var ecartType = CalculerEcartType(notes);
        var qualiteCopie = DetecterQualiteCopie(evaluations);
        
        Console.WriteLine($"üìä Qualit√© d√©tect√©e : {qualiteCopie}");
        Console.WriteLine($"üìä √âcart-type des notes : {ecartType:F2}");
        Console.WriteLine($"üìä Type de devoir : {typeDevoir}");
        
        if (typeBac == "technologique")
        {
            // Ajustement diff√©rent selon le type de devoir
            if (typeDevoir?.ToLower() == "explication")
            {
                // Pour les explications : ajustements TR√àS mod√©r√©s
                switch (qualiteCopie)
                {
                    case "bonne":
                        if (moyenne < 10)
                        {
                            moyenne = moyenne * 1.10; // +10% seulement si tr√®s sous-√©valu√©e
                            Console.WriteLine("‚úÖ Ajustement mod√©r√© pour explication bonne qualit√© sous-√©valu√©e");
                        }
                        else if (moyenne < 12)
                        {
                            moyenne = moyenne * 1.05; // +5%
                            Console.WriteLine("‚úÖ Ajustement l√©ger pour explication bonne qualit√©");
                        }
                        else
                        {
                            moyenne = moyenne * 1.00; // Pas d'ajustement (d√©j√† correcte)
                            Console.WriteLine("‚úÖ Pas d'ajustement pour explication d√©j√† bien not√©e");
                        }
                        break;
                        
                    case "faible":
                        moyenne = moyenne * 0.85; // -15%
                        Console.WriteLine("üìâ Ajustement n√©gatif pour explication faible");
                        break;
                        
                    default: // moyenne
                        moyenne = moyenne * 1.00; // Pas d'ajustement
                        Console.WriteLine("üîÑ Pas d'ajustement pour explication moyenne");
                        break;
                }
            }
            else
            {
                // Pour les dissertations : ajustements plus significatifs
                switch (qualiteCopie)
                {
                    case "bonne":
                        if (moyenne < 13)
                        {
                            moyenne = moyenne * 1.35; // +35% si sous-√©valu√©e
                            Console.WriteLine("‚úÖ Ajustement positif fort pour dissertation bonne qualit√© sous-√©valu√©e");
                        }
                        else if (moyenne < 15)
                        {
                            moyenne = moyenne * 1.20; // +20%
                            Console.WriteLine("‚úÖ Ajustement positif mod√©r√© pour dissertation bonne qualit√©");
                        }
                        else
                        {
                            moyenne = moyenne * 1.05; // +5% (d√©j√† bien not√©e)
                            Console.WriteLine("‚úÖ Ajustement positif l√©ger pour dissertation d√©j√† bien not√©e");
                        }
                        break;
                        
                    case "faible":
                        moyenne = moyenne * 0.80; // -20%
                        Console.WriteLine("üìâ Ajustement n√©gatif pour dissertation faible");
                        break;
                        
                    default: // moyenne
                        moyenne = moyenne * 1.02; // +2% (bienveillance bac techno)
                        Console.WriteLine("üîÑ Ajustement neutre bienveillant pour dissertation moyenne");
                        break;
                }
            }
            
            // Contraintes finales
            moyenne = Math.Max(moyenne, 6.0);  // Minimum 6/20
            moyenne = Math.Min(moyenne, 18.5); // Maximum 18.5/20
            
            return Math.Round(moyenne, 1);
        }
        
        return Math.Round(moyenne, 1);

    }

    /// <summary>
    /// Calcule l'√©cart-type pour d√©tecter si les notes sont trop uniformes
    /// </summary>
    private double CalculerEcartType(List<double> notes)
    {
        if (notes.Count <= 1) return 0;

        var moyenne = notes.Average();
        var variance = notes.Sum(x => Math.Pow(x - moyenne, 2)) / notes.Count;
        return Math.Sqrt(variance);
    }

    /// <summary>
    /// Valide qu'une copie respecte les crit√®res minimums
    /// </summary>
    public static bool ValiderCopie(string copie, int longueurMinimum = 500)
    {
        return !string.IsNullOrWhiteSpace(copie) && copie.Length >= longueurMinimum;
    }

    /// <summary>
    /// Affiche les r√©sultats de correction de mani√®re format√©e
    /// </summary>
    public static void AfficherResultatsCorrection(Correction correction, List<Competence> competences)
    {
        //Console.Clear();
        Console.WriteLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        Console.WriteLine("‚ïë                R√âSULTATS DE CORRECTION               ‚ïë");
        Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        Console.WriteLine($"\nüéØ NOTE FINALE : {correction.Note:F1}/20");
        Console.WriteLine($"üìÖ Date de correction : {correction.DateCorrection:dd/MM/yyyy HH:mm}");

        // Afficher les m√©triques linguistiques si disponibles dans l'appr√©ciation
        if (correction.Copie != null)
        {
            var (nombreMots, motsUniques, richesseVocabulaire, motsPlusFrequents) = AnalyserMetriquesLinguistiquesStatic(correction.Copie);
            var mtld = CalculerMTLDStatic(correction.Copie);
            
            Console.WriteLine("\n" + new string('‚ïê', 60));
            Console.WriteLine("üìä M√âTRIQUES LINGUISTIQUES");
            Console.WriteLine(new string('‚ïê', 60));
            Console.WriteLine($"üìù Longueur : {nombreMots} mots ({motsUniques} uniques, {richesseVocabulaire:F1}% de richesse)");
            Console.WriteLine($"ÔøΩ Mots les plus utilis√©s : {string.Join(", ", motsPlusFrequents.Take(8))}");
            Console.WriteLine($"üéØ Diversit√© lexicale (MTLD) : {mtld:F1}");
            
            // Afficher l'interpr√©tation MTLD si elle a √©t√© stock√©e dans l'appr√©ciation
            if (correction.Appreciation?.Contains("[Analyse linguistique MTLD:") == true)
            {
                var startIndex = correction.Appreciation.IndexOf("[Analyse linguistique MTLD:") + "[Analyse linguistique MTLD:".Length;
                var endIndex = correction.Appreciation.IndexOf("]", startIndex);
                if (endIndex > startIndex)
                {
                    var analyseMTLD = correction.Appreciation.Substring(startIndex, endIndex - startIndex).Trim();
                    Console.WriteLine($"üéì Interpr√©tation p√©dagogique : {analyseMTLD}");
                }
            }
            else
            {
                // Calculer l'interpr√©tation MTLD si elle n'est pas stock√©e
                var interpretationMTLD = InterpreterMTLDStatic(mtld, nombreMots, "dissertation", "g√©n√©ral");
                Console.WriteLine($"üéì Interpr√©tation p√©dagogique : {interpretationMTLD}");
            }
        }

        Console.WriteLine("\n" + new string('‚ïê', 60));
        Console.WriteLine("üí¨ APPR√âCIATION G√âN√âRALE");
        Console.WriteLine(new string('‚ïê', 60));
        Console.WriteLine(correction.Appreciation);

        Console.WriteLine("\n" + new string('‚îÄ', 60));
        Console.WriteLine("‚úÖ POINTS FORTS");
        Console.WriteLine(new string('‚îÄ', 60));
        if (correction.PointsForts != null)
        {
            foreach (var point in correction.PointsForts)
            {
                Console.WriteLine($"‚Ä¢ {point}");
            }
        }

        Console.WriteLine("\n" + new string('‚îÄ', 60));
        Console.WriteLine("üìà POINTS √Ä AM√âLIORER");
        Console.WriteLine(new string('‚îÄ', 60));
        if (correction.PointsAmeliorer != null)
        {
            foreach (var point in correction.PointsAmeliorer)
            {
                Console.WriteLine($"‚Ä¢ {point}");
            }
        }

        Console.WriteLine("\n" + new string('‚ïê', 60));
        Console.WriteLine("üìä D√âTAIL PAR COMP√âTENCE");
        Console.WriteLine(new string('‚ïê', 60));

        if (correction.Competences != null)
        {
            for (int i = 0; i < correction.Competences.Count; i++)
            {
                var eval = correction.Competences[i];
                Console.WriteLine($"\n{i + 1}. {eval.Nom} - {eval.Note:F1}/20");
                Console.WriteLine($"   {eval.Analyse}");

                if (eval.PointsForts?.Count > 0)
                {
                    Console.WriteLine("   ‚úÖ Points forts :");
                    foreach (var point in eval.PointsForts)
                    {
                        Console.WriteLine($"      ‚Ä¢ {point}");
                    }
                }

                if (eval.PointsAmeliorer?.Count > 0)
                {
                    Console.WriteLine("   üìà √Ä am√©liorer :");
                    foreach (var point in eval.PointsAmeliorer)
                    {
                        Console.WriteLine($"      ‚Ä¢ {point}");
                    }
                }
            }
        }

        Console.WriteLine($"\n‚úÖ Correction sauvegard√©e avec l'ID : {correction.Id}");
    }

    /// <summary>
    /// Exporte une correction vers un fichier .txt bien format√©
    /// </summary>
    public static async Task<string> ExporterCorrectionAsync(Correction correction, Devoir devoir, string cheminDossier = "")
    {
        // Toujours utiliser le dossier en cours
        var dossierExport = Environment.CurrentDirectory;

        // Cr√©er le nom du fichier
        var dateCorrection = correction.DateCorrection.ToString("yyyy-MM-dd_HH-mm");
        var sujetCourt = devoir.Titre?.Replace(" ", "_").Replace("?", "").Replace(":", "").Replace("/", "_") ?? "Sujet";
        var nomFichier = $"Correction_{sujetCourt}_{dateCorrection}.txt";

        // Chemin complet
        var cheminComplet = Path.Combine(dossierExport, "Exports", nomFichier);

        // Cr√©er le dossier s'il n'existe pas
        Directory.CreateDirectory(Path.GetDirectoryName(cheminComplet)!);

        var contenu = new StringBuilder();

        // En-t√™te
        contenu.AppendLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        contenu.AppendLine("‚ïë                           CORRECTION DE COPIE                               ‚ïë");
        contenu.AppendLine("‚ïë                             PHILOSOPHIX                                     ‚ïë");
        contenu.AppendLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        contenu.AppendLine();

        // Informations g√©n√©rales
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine("üìã INFORMATIONS G√âN√âRALES");
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine($"üìÖ Date de correction : {correction.DateCorrection:dd/MM/yyyy √† HH:mm}");
        contenu.AppendLine($"üìù Sujet : {devoir.Titre}");
        contenu.AppendLine($"üìñ √ânonc√© : {devoir.Enonce}");
        contenu.AppendLine($"üéØ Type de devoir : {devoir.Type}");
        contenu.AppendLine($"üéì Type de bac : {devoir.TypeBac}");
        contenu.AppendLine($"üèÜ NOTE FINALE : {correction.Note:F1}/20");
        contenu.AppendLine();

        // Appr√©ciation g√©n√©rale
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine("üí¨ APPR√âCIATION G√âN√âRALE");
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine(correction.Appreciation);
        contenu.AppendLine();

        // Points forts
        contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        contenu.AppendLine("‚úÖ POINTS FORTS");
        contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        if (correction.PointsForts != null && correction.PointsForts.Count > 0)
        {
            foreach (var point in correction.PointsForts)
            {
                contenu.AppendLine($"‚Ä¢ {point}");
            }
        }
        else
        {
            contenu.AppendLine("Aucun point fort sp√©cifique identifi√©.");
        }
        contenu.AppendLine();

        // Points √† am√©liorer
        contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        contenu.AppendLine("üìà POINTS √Ä AM√âLIORER");
        contenu.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        if (correction.PointsAmeliorer != null && correction.PointsAmeliorer.Count > 0)
        {
            foreach (var point in correction.PointsAmeliorer)
            {
                contenu.AppendLine($"‚Ä¢ {point}");
            }
        }
        else
        {
            contenu.AppendLine("Aucun point d'am√©lioration sp√©cifique identifi√©.");
        }
        contenu.AppendLine();

        // D√©tail par comp√©tence
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine("üìä √âVALUATION D√âTAILL√âE PAR COMP√âTENCE");
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        if (correction.Competences != null && correction.Competences.Count > 0)
        {
            for (int i = 0; i < correction.Competences.Count; i++)
            {
                var eval = correction.Competences[i];

                contenu.AppendLine($"\n{i + 1}. {(eval.Nom != null ? eval.Nom.ToUpper() : "COMP√âTENCE SANS NOM")}");
                contenu.AppendLine($"   Note : {eval.Note:F1}/20");
                contenu.AppendLine("   " + new string('‚îÄ', 75));

                // Analyse d√©taill√©e
                contenu.AppendLine("   üìù Analyse :");
                var lignesAnalyse = eval.Analyse?.Split('\n') ?? new[] { "Aucune analyse disponible." };
                foreach (var ligne in lignesAnalyse)
                {
                    contenu.AppendLine($"   {ligne}");
                }
                contenu.AppendLine();

                // Points forts de la comp√©tence
                if (eval.PointsForts?.Count > 0)
                {
                    contenu.AppendLine("   ‚úÖ Points forts :");
                    foreach (var point in eval.PointsForts)
                    {
                        contenu.AppendLine($"      ‚Ä¢ {point}");
                    }
                    contenu.AppendLine();
                }

                // Points √† am√©liorer de la comp√©tence
                if (eval.PointsAmeliorer?.Count > 0)
                {
                    contenu.AppendLine("   üìà √Ä am√©liorer :");
                    foreach (var point in eval.PointsAmeliorer)
                    {
                        contenu.AppendLine($"      ‚Ä¢ {point}");
                    }
                    contenu.AppendLine();
                }
            }
        }

        // Copie de l'√©l√®ve
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine("üìÑ COPIE DE L'√âL√àVE");
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine(correction.Copie);
        contenu.AppendLine();

        // Pied de page
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        contenu.AppendLine($"Correction g√©n√©r√©e par Philosophix le {DateTime.Now:dd/MM/yyyy √† HH:mm}");
        contenu.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        // √âcrire le fichier
        await File.WriteAllTextAsync(cheminComplet, contenu.ToString(), Encoding.UTF8);

        return cheminComplet;
    }
    
    /// <summary>
    /// Parse la r√©ponse de l'√©valuation d'une comp√©tence
    /// </summary>
    private EvaluationCompetence ParseEvaluationResponse(string apiResponse)
    {
        try
        {
            // Extraire le contenu JSON depuis la r√©ponse (OpenAI ou Ollama)
            var content = ExtraireContenuMessage(apiResponse);
            if (!string.IsNullOrEmpty(content))
            {
                // Nettoyer la r√©ponse des balises Markdown
                var cleanJson = content.Replace("```json", "").Replace("```", "").Trim();
                var evaluation = JsonSerializer.Deserialize<EvaluationApiResponse>(cleanJson, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
                
                var result = new EvaluationCompetence();
                result.Note = evaluation?.Note ?? 0;
                result.Analyse = evaluation?.Analyse;
                result.PointsForts = evaluation?.PointsForts;
                result.PointsAmeliorer = evaluation?.PointsAmeliorer;
                
                return result;
            }
            throw new Exception("Contenu vide");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du parsing : {ex.Message}");
            Console.WriteLine($"R√©ponse brute : {apiResponse.Substring(0, Math.Min(200, apiResponse.Length))}...");
            
            // Retourner une √©valuation par d√©faut en cas d'erreur
            var errorResult = new EvaluationCompetence();
            errorResult.Note = 10;
            errorResult.Analyse = "Erreur lors de l'analyse automatique";
            errorResult.PointsForts = new List<string> { "Analyse non disponible" };
            errorResult.PointsAmeliorer = new List<string> { "R√©essayer la correction" };
            
            return errorResult;
        }
    }

    /// <summary>
    /// Parse la r√©ponse de l'√©valuation finale
    /// </summary>
    private EvaluationFinaleApiResponse ParseEvaluationFinaleResponse(string apiResponse)
    {
        try
        {
            var content = ExtraireContenuMessage(apiResponse);
            if (!string.IsNullOrEmpty(content))
            {
                // Nettoyer la r√©ponse des balises Markdown
                var cleanJson = content.Replace("```json", "").Replace("```", "").Trim();
                var evaluation = JsonSerializer.Deserialize<EvaluationFinaleApiResponse>(cleanJson, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
                
                return evaluation ?? new EvaluationFinaleApiResponse
                {
                    Appreciation = "Erreur lors de la g√©n√©ration de l'appr√©ciation",
                    PointsForts = new List<string> { "Analyse non disponible" },
                    PointsAmeliorer = new List<string> { "R√©essayer la correction" }
                };
            }
            throw new Exception("Contenu vide");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors du parsing de l'√©valuation finale : {ex.Message}");
            Console.WriteLine($"R√©ponse brute : {apiResponse.Substring(0, Math.Min(200, apiResponse.Length))}...");
            
            // Retourner une √©valuation par d√©faut en cas d'erreur
            return new EvaluationFinaleApiResponse
            {
                Appreciation = "Erreur lors de la g√©n√©ration de l'appr√©ciation automatique",
                PointsForts = new List<string> { "Analyse non disponible" },
                PointsAmeliorer = new List<string> { "R√©essayer la correction" }
            };
        }
    }    /// <summary>
    /// Extrait le contenu du message depuis une r√©ponse LLM (OpenAI ou Ollama)
    /// </summary>
    private string ExtraireContenuMessage(string response)
    {
        try
        {
            using var document = JsonDocument.Parse(response);
            var root = document.RootElement;

            // Format OpenAI
            if (root.TryGetProperty("choices", out var choices) && choices.GetArrayLength() > 0)
            {
                var firstChoice = choices[0];
                if (firstChoice.TryGetProperty("message", out var message))
                {
                    if (message.TryGetProperty("content", out var content))
                    {
                        return content.GetString() ?? "";
                    }
                }
            }

            // Format Ollama
            if (root.TryGetProperty("message", out var ollamaMessage))
            {
                if (ollamaMessage.TryGetProperty("content", out var ollamaContent))
                {
                    var contentStr = ollamaContent.GetString() ?? "";
                    
                    // Si la r√©ponse Ollama contient du texte non-JSON, essayer d'extraire le JSON
                    if (!contentStr.Trim().StartsWith("{"))
                    {
                        // Chercher un bloc JSON dans la r√©ponse
                        var jsonStart = contentStr.IndexOf('{');
                        var jsonEnd = contentStr.LastIndexOf('}');
                        
                        if (jsonStart >= 0 && jsonEnd > jsonStart)
                        {
                            contentStr = contentStr.Substring(jsonStart, jsonEnd - jsonStart + 1);
                        }
                    }
                    
                    return contentStr;
                }
            }

            // Si on ne trouve pas la structure attendue, retourner la r√©ponse brute
            return response;
        }
        catch (JsonException)
        {            
            // Si ce n'est pas du JSON, c'est peut-√™tre d√©j√† le contenu pur
            // Essayer d'extraire un JSON de la r√©ponse texte
            var responseText = response;
            var jsonStart = responseText.IndexOf('{');
            var jsonEnd = responseText.LastIndexOf('}');
            
            if (jsonStart >= 0 && jsonEnd > jsonStart)
            {
                return responseText.Substring(jsonStart, jsonEnd - jsonStart + 1);
            }
            
            return response;
        }
    }    /// <summary>
    /// Lance le processus de correction avec consensus (multi-√©valuations)
    /// </summary>
    public async Task<Correction> CorrigerCopieAvecConsensusAsync(Devoir devoir, string copie, int nombreEvaluations = 20, int maxParallelism = 5, bool aPAP = false)
    {
        Console.WriteLine("\n" + new string('‚ïê', 60));
        Console.WriteLine($"ü§ñ CORRECTION AVEC CONSENSUS ({nombreEvaluations} √©valuations par comp√©tence)");
        Console.WriteLine("üèõÔ∏è  Simulation d'une commission d'harmonisation");
        Console.WriteLine(new string('‚ïê', 60));

        // Analyse linguistique de la copie
        var (nombreMots, motsUniques, richesseVocabulaire, motsPlusFrequents) = AnalyserMetriquesLinguistiques(copie);
        var mtld = CalculerMTLD(copie);
        var analyseLinguistique = InterpreterMTLD(mtld, nombreMots, devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral");
        
        Console.WriteLine($"üìä ANALYSE LINGUISTIQUE :");
        Console.WriteLine($"   ‚Ä¢ Longueur : {nombreMots} mots ({motsUniques} uniques, {richesseVocabulaire:F1}% de richesse)");
        var qualiteMTLD = mtld >= 50 ? "excellent" : mtld >= 40 ? "tr√®s bon" : mtld >= 30 ? "correct" : mtld >= 20 ? "faible" : "tr√®s faible";
        Console.WriteLine($"   ‚Ä¢ Diversit√© lexicale (MTLD) : {mtld:F1} ({qualiteMTLD})");
        Console.WriteLine($"   ‚Ä¢ Mots les plus fr√©quents : {string.Join(", ", motsPlusFrequents.Take(5))}");
        Console.WriteLine();

        var competences = devoir.Bareme?.Competences ?? new List<Competence>();
        
        // Filtrer les comp√©tences si PAP
        if (aPAP)
        {
            Console.WriteLine("‚ÑπÔ∏è  PAP activ√© : Les comp√©tences d'expression ne seront pas √©valu√©es.");
            if (devoir.Type?.ToLower() == "explication")
            {
                competences = competences.Where(c => c.Nom != "Expression et r√©daction").ToList();
            }
            else
            {
                competences = competences.Where(c => c.Nom != "Ma√Ætrise de la langue fran√ßaise").ToList();
            }
        }

        var evaluationsFinales = new List<EvaluationCompetence>();

        // √âvaluation par comp√©tence avec consensus
        for (int i = 0; i < competences.Count; i++)
        {
            var competence = competences[i];
            Console.WriteLine($"\nüìã Consensus pour la comp√©tence {i + 1}/{competences.Count}:");
            Console.WriteLine($"   {competence.Nom}");            // G√©n√©rer N corrections pour cette comp√©tence EN PARALL√àLE
            var evaluationsMultiples = new List<EvaluationCompetence>();
            var startTime = DateTime.Now;
            
            // Configuration du parall√©lisme
            var semaphore = new SemaphoreSlim(maxParallelism, maxParallelism);
            var tasks = new List<Task<EvaluationCompetence>>();
            var progressCounter = 0;
            
            Console.Write($"\r   üìä D√©marrage de {nombreEvaluations} √©valuations parall√®les (max {maxParallelism} simultan√©es)");
            
            // Cr√©er toutes les t√¢ches
            for (int j = 0; j < nombreEvaluations; j++)
            {
                tasks.Add(EvaluerCompetenceAvecSemaphoreAsync(competence, copie, devoir.Enonce ?? "", devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral", aPAP, semaphore, () =>
                {
                    var current = Interlocked.Increment(ref progressCounter);
                    if (current % 10 == 0 || current == nombreEvaluations)
                    {
                        Console.Write($"\r   üìä Progression: {current}/{nombreEvaluations} √©valuations termin√©es");
                    }
                }));
            }
            
            // Attendre que toutes les t√¢ches se terminent
            var resultats = await Task.WhenAll(tasks);
            evaluationsMultiples.AddRange(resultats);
            
            var endTime = DateTime.Now;
            var duration = endTime - startTime;
              // Calculer le consensus
            var consensus = CalculerConsensus(evaluationsMultiples, competence.Nom ?? "Comp√©tence sans nom");
            evaluationsFinales.Add(consensus);
            
            // Afficher les statistiques
            var notes = evaluationsMultiples.Select(e => e.Note).ToList();
            var ecartType = CalculerEcartTypeNotes(notes);
            var noteMin = notes.Min();
            var noteMax = notes.Max();
            var mediane = CalculerMediane(notes);
            
            Console.WriteLine($"\r   ‚úÖ Consensus: {consensus.Note:F1}/20");
            Console.WriteLine($"      üìä Min: {noteMin:F1} | Max: {noteMax:F1} | M√©diane: {mediane:F1} | √âcart-type: {ecartType:F2}");
            Console.WriteLine($"      ‚è±Ô∏è  Temps: {duration.TotalSeconds:F1}s");
        }

        // √âvaluation finale
        Console.WriteLine("\nüéØ G√©n√©ration de l'√©valuation finale...");
        var evaluationFinale = await EvaluerFinalAsync(evaluationsFinales, competences, copie, devoir.Type ?? "dissertation", devoir.TypeBac ?? "g√©n√©ral", aPAP);

        // Afficher le r√©sum√© des co√ªts
        Console.WriteLine("\n" + new string('‚îÄ', 60));
        _llmService.CostTracker?.DisplayCostSummary();

        // Calcul de la note moyenne avec pond√©ration
        var notesFinales = evaluationsFinales.Select(e => e.Note).ToList();
        var notesFinalesDouble = notesFinales.Select(n => Convert.ToDouble(n)).ToList();
        var noteMoyenne = AppliquerPonderation(notesFinalesDouble, devoir.TypeBac ?? "g√©n√©ral", evaluationsFinales, devoir.Type ?? "dissertation");

        // Affichage des statistiques finales
        Console.WriteLine($"\nüìä STATISTIQUES FINALES :");
        Console.WriteLine($"   ‚Ä¢ Note moyenne des comp√©tences : {evaluationsFinales.Average(e => e.Note):F1}/20");
        Console.WriteLine($"   ‚Ä¢ Note finale apr√®s pond√©ration : {noteMoyenne:F1}/20");
        Console.WriteLine($"   ‚Ä¢ √âcart-type des notes finales : {CalculerEcartTypeNotes(notesFinales):F2}");

        // Cr√©ation de la correction
        var corrections = await _dbService.LireCorrectionsAsync();
        var newId = corrections.Count > 0 ? corrections.Max(c => c.Id) + 1 : 1;

        var correction = new Correction
        {
            Id = newId,
            DevoirId = devoir.Id,
            Note = (decimal)noteMoyenne,
            Appreciation = evaluationFinale.Appreciation + $"\n\n[Analyse linguistique MTLD: {analyseLinguistique}]" + $"\n\n[Note : Cette correction a √©t√© r√©alis√©e avec un consensus de {nombreEvaluations} √©valuations par comp√©tence pour garantir une notation √©quitable et harmonis√©e.]",
            PointsForts = evaluationFinale.PointsForts,
            PointsAmeliorer = evaluationFinale.PointsAmeliorer,
            Competences = evaluationsFinales,
            Copie = copie,
            DateCorrection = DateTime.Now
        };

        corrections.Add(correction);
        await _dbService.SauvegarderCorrectionsAsync(corrections);

        return correction;
    }

    /// <summary>
    /// √âvalue une comp√©tence avec gestion du parall√©lisme via semaphore
    /// </summary>
    private async Task<EvaluationCompetence> EvaluerCompetenceAvecSemaphoreAsync(
        Competence competence, string copie, string enonce, string typeDevoir, string TypeBac, 
        bool aPAP, SemaphoreSlim semaphore, Action? onCompleted = null)
    {
        await semaphore.WaitAsync();
        try
        {
            var evaluation = await EvaluerCompetenceAsync(competence, copie, enonce, typeDevoir, TypeBac, aPAP);
            onCompleted?.Invoke();
            return evaluation;
        }
        finally
        {
            semaphore.Release();
        }
    }

    /// <summary>
    /// Calcule le consensus √† partir de multiples √©valuations d'une comp√©tence
    /// </summary>
    private EvaluationCompetence CalculerConsensus(List<EvaluationCompetence> evaluations, string nomCompetence)
    {
        var notes = evaluations.Select(e => e.Note).ToList();
        
        // √âliminer les outliers (m√©thode IQR)
        var notesFiltrees = EliminerOutliers(notes);
        
        return new EvaluationCompetence
        {
            Nom = nomCompetence,
            Note = notesFiltrees.Count > 0 ? notesFiltrees.Average() : notes.Average(),
            Analyse = SynthetiserAnalyses(evaluations),
            PointsForts = ExtrairePointsRecurrents(evaluations.SelectMany(e => e.PointsForts ?? new List<string>())),
            PointsAmeliorer = ExtrairePointsRecurrents(evaluations.SelectMany(e => e.PointsAmeliorer ?? new List<string>()))
        };
    }

    /// <summary>
    /// √âlimine les outliers en utilisant la m√©thode IQR (Interquartile Range)
    /// </summary>
    private List<decimal> EliminerOutliers(List<decimal> notes)
    {
        if (notes.Count < 4) return notes; // Pas assez de donn√©es pour √©liminer des outliers
        
        var sorted = notes.OrderBy(n => n).ToList();
        var q1Index = (int)(sorted.Count * 0.25);
        var q3Index = (int)(sorted.Count * 0.75);
        
        var q1 = sorted[q1Index];
        var q3 = sorted[q3Index];
        var iqr = q3 - q1;
        var lowerBound = q1 - 1.5m * iqr;
        var upperBound = q3 + 1.5m * iqr;
        
        var filtrees = sorted.Where(n => n >= lowerBound && n <= upperBound).ToList();
        
        // Si on √©limine plus de 20% des donn√©es, on garde toutes les donn√©es
        if (filtrees.Count < notes.Count * 0.8)
        {
            return notes;
        }
        
        return filtrees;
    }

    /// <summary>
    /// Synth√©tise les analyses de multiples √©valuations en une analyse consensus
    /// </summary>
    private string SynthetiserAnalyses(List<EvaluationCompetence> evaluations)
    {
        // Extraire les phrases les plus r√©currentes
        var toutesAnalyses = evaluations.Select(e => e.Analyse ?? "").ToList();
        
        // Pour l'instant, on prend l'analyse m√©diane en termes de longueur
        // Dans une version plus avanc√©e, on pourrait faire de l'analyse de sentiments
        var analysesTriees = toutesAnalyses.OrderBy(a => a.Length).ToList();
        var indexMedian = analysesTriees.Count / 2;
        
        var analyseBase = analysesTriees[indexMedian];
        
        return $"{analyseBase}\n\n[Cette analyse repr√©sente le consensus de {evaluations.Count} √©valuations pour garantir l'objectivit√©.]";
    }

    /// <summary>
    /// Extrait les points r√©currents d'une liste de points
    /// </summary>
    private List<string> ExtrairePointsRecurrents(IEnumerable<string> points)
    {
        // Compter la fr√©quence des points similaires
        var pointsFrequence = new Dictionary<string, int>();
        
        foreach (var point in points)
        {
            var pointNormalise = NormaliserTexte(point);
            if (pointsFrequence.ContainsKey(pointNormalise))
            {
                pointsFrequence[pointNormalise]++;
            }
            else
            {
                pointsFrequence[pointNormalise] = 1;
            }
        }
        
        // Retourner les points qui apparaissent au moins 2 fois (pour √©viter les points uniques)
        var seuilMinimum = Math.Max(2, pointsFrequence.Count / 10); // Au moins 2, ou 10% des points
        
        return pointsFrequence
            .Where(kv => kv.Value >= seuilMinimum)
            .OrderByDescending(kv => kv.Value)
            .Take(5) // Maximum 5 points
            .Select(kv => kv.Key)
            .ToList();
    }

    /// <summary>
    /// Normalise un texte pour la comparaison (minuscules, suppression ponctuation, etc.)
    /// </summary>
    private string NormaliserTexte(string texte)
    {
        if (string.IsNullOrEmpty(texte)) return "";
        
        return texte.ToLower()
                   .Replace(".", "")
                   .Replace(",", "")
                   .Replace("!", "")
                   .Replace("?", "")
                   .Replace(";", "")
                   .Replace(":", "")
                   .Trim();
    }

    /// <summary>
    /// Calcule l'√©cart-type d'une liste de notes
    /// </summary>
    private double CalculerEcartTypeNotes(List<decimal> notes)
    {
        if (notes.Count <= 1) return 0;

        var moyenne = notes.Average();
        var variance = notes.Sum(x => Math.Pow((double)(x - moyenne), 2)) / notes.Count;
        return Math.Sqrt(variance);
    }

    /// <summary>
    /// Calcule la m√©diane d'une liste de notes
    /// </summary>
    private decimal CalculerMediane(List<decimal> notes)
    {
        var sorted = notes.OrderBy(n => n).ToList();
        var count = sorted.Count;
        
        if (count % 2 == 0)
        {
            return (sorted[count / 2 - 1] + sorted[count / 2]) / 2;
        }
        else
        {
            return sorted[count / 2];
        }
    }

    /// <summary>
    /// Analyse les m√©triques linguistiques d'une copie
    /// </summary>
    private (int nombreMots, int motsUniques, double richesseVocabulaire, List<string> motsPlusFrequents) AnalyserMetriquesLinguistiques(string copie)
    {
        if (string.IsNullOrWhiteSpace(copie))
            return (0, 0, 0, new List<string>());

        // Nettoyer et diviser le texte en mots
        var mots = copie
            .ToLower()
            .Split(new char[] { ' ', '\n', '\r', '\t', '.', ',', ';', ':', '!', '?', '"', '\'', '(', ')', '[', ']', '{', '}', '-', '‚Äî', '‚Ä¶' }, 
                   StringSplitOptions.RemoveEmptyEntries)
            .Where(mot => mot.Length > 2) // Ignorer les mots trop courts
            .Where(mot => !EstMotVideStatic(mot)) // Ignorer les mots vides
            .ToList();

        var nombreMots = mots.Count;
        var motsUniques = mots.Distinct().Count();
        var richesseVocabulaire = nombreMots > 0 ? (double)motsUniques / nombreMots * 100 : 0;

        // Analyser la fr√©quence des mots
        var frequenceMots = mots
            .GroupBy(mot => mot)
            .OrderByDescending(g => g.Count())
            .Take(10)
            .Select(g => $"{g.Key} ({g.Count()})")
            .ToList();

        return (nombreMots, motsUniques, richesseVocabulaire, frequenceMots);
    }

    /// <summary>
    /// Analyse les m√©triques linguistiques d'une copie (version publique statique)
    /// </summary>
    public static (int nombreMots, int motsUniques, double richesseVocabulaire, List<string> motsPlusFrequents) AnalyserMetriquesLinguistiquesStatic(string copie)
    {
        if (string.IsNullOrWhiteSpace(copie))
            return (0, 0, 0, new List<string>());

        // Nettoyer et diviser le texte en mots
        var mots = copie
            .ToLower()
            .Split(new char[] { ' ', '\n', '\r', '\t', '.', ',', ';', ':', '!', '?', '"', '\'', '(', ')', '[', ']', '{', '}', '-', '‚Äî', '‚Ä¶' }, 
                   StringSplitOptions.RemoveEmptyEntries)
            .Where(mot => mot.Length > 2) // Ignorer les mots trop courts
            .Where(mot => !EstMotVideStatic(mot)) // Ignorer les mots vides
            .ToList();

        var nombreMots = mots.Count;
        var motsUniques = mots.Distinct().Count();
        var richesseVocabulaire = nombreMots > 0 ? (double)motsUniques / nombreMots * 100 : 0;

        // Analyser la fr√©quence des mots
        var frequenceMots = mots
            .GroupBy(mot => mot)
            .OrderByDescending(g => g.Count())
            .Take(10)
            .Select(g => $"{g.Key} ({g.Count()})")
            .ToList();

        return (nombreMots, motsUniques, richesseVocabulaire, frequenceMots);
    }

    /// <summary>
    /// D√©termine si un mot est un mot vide (version statique)
    /// </summary>
    private static bool EstMotVideStatic(string mot)
    {
        var motsVides = new HashSet<string>
        {
            "le", "la", "les", "un", "une", "des", "du", "de", "d'", "et", "ou", "o√π", "est", "sont", "√©tait", "√©taient",
            "a", "ai", "as", "ont", "avait", "avaient", "aura", "auront", "sera", "seront", "serait", "seraient",
            "ce", "cette", "ces", "cet", "se", "s'", "si", "sa", "son", "ses", "leur", "leurs", "notre", "nos", "votre", "vos",
            "je", "tu", "il", "elle", "nous", "vous", "ils", "elles", "me", "te", "lui", "nous", "vous", "leur",
            "que", "qui", "quoi", "dont", "lequel", "laquelle", "lesquels", "lesquelles",
            "dans", "sur", "sous", "avec", "sans", "pour", "par", "vers", "chez", "entre", "parmi", "selon", "malgr√©",
            "mais", "car", "donc", "or", "ni", "cependant", "n√©anmoins", "toutefois", "pourtant", "ainsi", "alors", "aussi",
            "tr√®s", "plus", "moins", "assez", "trop", "bien", "mal", "mieux", "beaucoup", "peu", "tant", "autant",
            "ici", "l√†", "hier", "aujourd'hui", "demain", "maintenant", "d√©j√†", "encore", "toujours", "jamais", "parfois"
        };

        return motsVides.Contains(mot);
    }

    /// <summary>
    /// √âvalue la qualit√© linguistique d'une copie (version statique)
    /// </summary>
    public static string EvaluerQualiteLinguistiqueStatic(int nombreMots, double richesseVocabulaire)
    {
        string evaluationLongueur;
        string evaluationRichesse;

        // √âvaluation de la longueur
        if (nombreMots < 300)
            evaluationLongueur = "tr√®s courte";
        else if (nombreMots < 500)
            evaluationLongueur = "courte";
        else if (nombreMots < 800)
            evaluationLongueur = "correcte";
        else if (nombreMots < 1200)
            evaluationLongueur = "d√©velopp√©e";
        else
            evaluationLongueur = "tr√®s d√©velopp√©e";

        // √âvaluation de la richesse vocabulaire
        if (richesseVocabulaire < 30)
            evaluationRichesse = "vocabulaire limit√©";
        else if (richesseVocabulaire < 40)
            evaluationRichesse = "vocabulaire correct";
        else if (richesseVocabulaire < 50)
            evaluationRichesse = "vocabulaire riche";
        else if (richesseVocabulaire < 60)
            evaluationRichesse = "vocabulaire tr√®s riche";
        else
            evaluationRichesse = "vocabulaire exceptionnel";

        return $"Copie {evaluationLongueur} ({nombreMots} mots) avec un {evaluationRichesse} ({richesseVocabulaire:F1}% de mots uniques)";
    }

    /// <summary>
    /// Analyse les m√©triques linguistiques avec l'aide du LLM pour une interpr√©tation p√©dagogique
    /// </summary>
    /// <summary>
    /// Calcule le MTLD (Measure of Textural Lexical Diversity) d'un texte
    /// </summary>
    private double CalculerMTLD(string copie, double seuil = 0.72)
    {
        if (string.IsNullOrWhiteSpace(copie))
            return 0;

        // Nettoyer et diviser le texte en mots
        var mots = copie
            .ToLower()
            .Split(new char[] { ' ', '\n', '\r', '\t', '.', ',', ';', ':', '!', '?', '"', '\'', '(', ')', '[', ']', '{', '}', '-', '‚Äî', '‚Ä¶' }, 
                   StringSplitOptions.RemoveEmptyEntries)
            .Where(mot => mot.Length > 2)
            .Where(mot => !EstMotVide(mot))
            .ToList();

        if (mots.Count < 10) return 0; // Trop peu de mots pour calculer le MTLD

        // Analyse de gauche √† droite
        var segmentsGaucheDroite = CalculerSegmentsMTLD(mots, seuil);
        
        // Analyse de droite √† gauche
        var motsInverses = mots.ToList();
        motsInverses.Reverse();
        var segmentsDroiteGauche = CalculerSegmentsMTLD(motsInverses, seuil);

        // Calcul du MTLD final (moyenne des deux directions)
        var mtldGaucheDroite = segmentsGaucheDroite.Count > 0 ? segmentsGaucheDroite.Average() : 0;
        var mtldDroiteGauche = segmentsDroiteGauche.Count > 0 ? segmentsDroiteGauche.Average() : 0;

        return (mtldGaucheDroite + mtldDroiteGauche) / 2.0;
    }

    /// <summary>
    /// Calcule les segments MTLD pour une direction donn√©e
    /// </summary>
    private List<int> CalculerSegmentsMTLD(List<string> mots, double seuil)
    {
        var segments = new List<int>();
        var motsVus = new HashSet<string>();
        var indexDebut = 0;

        for (int i = 0; i < mots.Count; i++)
        {
            motsVus.Add(mots[i]);
            var ttr = (double)motsVus.Count / (i - indexDebut + 1);

            if (ttr < seuil)
            {
                // Fin d'un segment
                segments.Add(i - indexDebut + 1);
                motsVus.Clear();
                indexDebut = i + 1;
            }
        }

        // Ajouter le dernier segment partiel s'il y en a un
        if (indexDebut < mots.Count)
        {
            var dernierSegment = mots.Count - indexDebut;
            if (dernierSegment > 5) // Seulement si le segment est assez long
            {
                segments.Add(dernierSegment);
            }
        }

        return segments;
    }

    /// <summary>
    /// Version statique du calcul MTLD
    /// </summary>
    public static double CalculerMTLDStatic(string copie, double seuil = 0.72)
    {
        if (string.IsNullOrWhiteSpace(copie))
            return 0;

        // Nettoyer et diviser le texte en mots
        var mots = copie
            .ToLower()
            .Split(new char[] { ' ', '\n', '\r', '\t', '.', ',', ';', ':', '!', '?', '"', '\'', '(', ')', '[', ']', '{', '}', '-', '‚Äî', '‚Ä¶' }, 
                   StringSplitOptions.RemoveEmptyEntries)
            .Where(mot => mot.Length > 2)
            .Where(mot => !EstMotVideStatic(mot))
            .ToList();

        if (mots.Count < 10) return 0;

        // Analyse de gauche √† droite
        var segmentsGaucheDroite = CalculerSegmentsMTLDStatic(mots, seuil);
        
        // Analyse de droite √† gauche
        var motsInverses = mots.ToList();
        motsInverses.Reverse();
        var segmentsDroiteGauche = CalculerSegmentsMTLDStatic(motsInverses, seuil);

        var mtldGaucheDroite = segmentsGaucheDroite.Count > 0 ? segmentsGaucheDroite.Average() : 0;
        var mtldDroiteGauche = segmentsDroiteGauche.Count > 0 ? segmentsDroiteGauche.Average() : 0;

        return (mtldGaucheDroite + mtldDroiteGauche) / 2.0;
    }

    /// <summary>
    /// Version statique du calcul des segments MTLD
    /// </summary>
    private static List<int> CalculerSegmentsMTLDStatic(List<string> mots, double seuil)
    {
        var segments = new List<int>();
        var motsVus = new HashSet<string>();
        var indexDebut = 0;

        for (int i = 0; i < mots.Count; i++)
        {
            motsVus.Add(mots[i]);
            var ttr = (double)motsVus.Count / (i - indexDebut + 1);

            if (ttr < seuil)
            {
                segments.Add(i - indexDebut + 1);
                motsVus.Clear();
                indexDebut = i + 1;
            }
        }

        if (indexDebut < mots.Count)
        {
            var dernierSegment = mots.Count - indexDebut;
            if (dernierSegment > 5)
            {
                segments.Add(dernierSegment);
            }
        }

        return segments;
    }

    /// <summary>
    /// Version statique de l'analyse linguistique avec LLM (pour l'affichage des r√©sultats)
    /// </summary>
    public static async Task<string> AnalyserMetriquesAvecLLMStaticAsync(ILLMService llmService, int nombreMots, double richesseVocabulaire, List<string> motsPlusFrequents, string typeDevoir, string typeBac)
    {
        var system = @"Vous √™tes un professeur de philosophie exp√©riment√© qui analyse les m√©triques linguistiques des copies d'√©l√®ves du baccalaur√©at. 
Votre r√¥le est d'interpr√©ter les donn√©es quantitatives pour donner des conseils p√©dagogiques pertinents et constructifs.
R√©pondez de mani√®re concise et bienveillante, en vous adressant directement √† l'√©l√®ve (vouvoiement).";

        var motsPlusFrequentsText = string.Join(", ", motsPlusFrequents.Take(8));
        var niveauAttendu = typeBac == "technologique" ? "bac technologique" : "bac g√©n√©ral";
        
        var prompt = $@"Analysez ces m√©triques linguistiques d'une copie de {typeDevoir} de {niveauAttendu} :

üìä DONN√âES :
- Nombre de mots : {nombreMots}
- Richesse du vocabulaire : {richesseVocabulaire:F1}% de mots uniques
- Mots les plus fr√©quents : {motsPlusFrequentsText}

CONTEXTE :
- Type de devoir : {typeDevoir}
- Niveau : {niveauAttendu}

Donnez une analyse p√©dagogique en 2-3 phrases maximum qui :
1. √âvalue la longueur par rapport aux attentes du bac
2. Commente la richesse vocabulaire (attention aux r√©p√©titions)
3. Identifie si les mots fr√©quents r√©v√®lent une bonne ma√Ætrise du sujet
4. Donne un conseil constructif si n√©cessaire

Soyez bienveillant mais pr√©cis. R√©pondez directement sans pr√©ambule.";

        try
        {
            var response = await llmService.AskAsync(system, prompt, "Analyse linguistique");
            
            // Extraire le contenu du message
            string analyseLLM = "";
            try
            {
                using var document = JsonDocument.Parse(response);
                var root = document.RootElement;

                // Format OpenAI
                if (root.TryGetProperty("choices", out var choices) && choices.GetArrayLength() > 0)
                {
                    var firstChoice = choices[0];
                    if (firstChoice.TryGetProperty("message", out var message))
                    {
                        if (message.TryGetProperty("content", out var content))
                        {
                            analyseLLM = content.GetString() ?? "";
                        }
                    }
                }

                // Format Ollama
                if (string.IsNullOrEmpty(analyseLLM) && root.TryGetProperty("message", out var ollamaMessage))
                {
                    if (ollamaMessage.TryGetProperty("content", out var ollamaContent))
                    {
                        analyseLLM = ollamaContent.GetString() ?? "";
                    }
                }
            }
            catch (JsonException)
            {
                // Si ce n'est pas du JSON, c'est peut-√™tre le contenu direct
                analyseLLM = response;
            }
            
            return analyseLLM?.Trim() ?? "Analyse linguistique non disponible.";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ö†Ô∏è  Erreur lors de l'analyse linguistique LLM : {ex.Message}");

            // Fallback vers l'analyse basique
            return EvaluerQualiteLinguistiqueStatic(nombreMots, richesseVocabulaire);
        }
    }

    /// <summary>
    /// D√©termine si un mot est un mot vide (version instance)
    /// </summary>
    /// <summary>
    /// Interpr√®te le score MTLD pour donner des conseils p√©dagogiques
    /// </summary>
    private string InterpreterMTLD(double mtld, int nombreMots, string typeDevoir, string typeBac)
    {
        return InterpreterMTLDStatic(mtld, nombreMots, typeDevoir, typeBac);
    }

    /// <summary>
    /// Version statique de l'interpr√©tation du score MTLD
    /// </summary>
    public static string InterpreterMTLDStatic(double mtld, int nombreMots, string typeDevoir, string typeBac)
    {
        string niveauAttendu = typeBac == "technologique" ? "bac technologique" : "bac g√©n√©ral";
        string contexte = typeDevoir == "explication" ? "explication de texte" : "dissertation philosophique";
        
        // Interpr√©tation du score MTLD selon les standards acad√©miques
        string interpretation;
        
        if (mtld >= 50)
        {
            interpretation = "excellent";
        }
        else if (mtld >= 40)
        {
            interpretation = "tr√®s satisfaisant";
        }
        else if (mtld >= 30)
        {
            interpretation = "satisfaisant";
        }
        else if (mtld >= 20)
        {
            interpretation = "insuffisant";
        }
        else
        {
            interpretation = "tr√®s insuffisant";
        }

        return $"Diversit√© lexicale {interpretation} (MTLD: {mtld:F1}).";
    }

    private bool EstMotVide(string mot)
    {
        var motsVides = new HashSet<string>
        {
            "le", "la", "les", "un", "une", "des", "du", "de", "d'", "et", "ou", "o√π", "est", "sont", "√©tait", "√©taient",
            "a", "ai", "as", "ont", "avait", "avaient", "aura", "auront", "sera", "seront", "serait", "seraient",
            "ce", "cette", "ces", "cet", "se", "s'", "si", "sa", "son", "ses", "leur", "leurs", "notre", "nos", "votre", "vos",
            "je", "tu", "il", "elle", "nous", "vous", "ils", "elles", "me", "te", "lui", "nous", "vous", "leur",
            "que", "qui", "quoi", "dont", "lequel", "laquelle", "lesquels", "lesquelles",
            "dans", "sur", "sous", "avec", "sans", "pour", "par", "vers", "chez", "entre", "parmi", "selon", "malgr√©",
            "mais", "car", "donc", "or", "ni", "cependant", "n√©anmoins", "toutefois", "pourtant", "ainsi", "alors", "aussi",
            "tr√®s", "plus", "moins", "assez", "trop", "bien", "mal", "mieux", "beaucoup", "peu", "tant", "autant",
            "ici", "l√†", "hier", "aujourd'hui", "demain", "maintenant", "d√©j√†", "encore", "toujours", "jamais", "parfois"
        };

        return motsVides.Contains(mot);
    }
}
